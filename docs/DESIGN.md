# План разработки Smart Ventilation Controller для Home Assistant

## Этап 1: Подготовка структуры проекта
**Цель**: Создать базовую структуру кастомного компонента

### 1.1 Создание файловой структуры
- [ ] Создать папку `custom_components/smart_vent/`
- [ ] Создать `__init__.py` (пустой файл для инициализации)
- [ ] Создать `manifest.json` с метаданными компонента
- [ ] Создать `const.py` для констант

### 1.2 Настройка manifest.json
- [ ] Указать название компонента: "Smart Ventilation Controller"
- [ ] Указать версию: "0.1.0"
- [ ] Указать зависимости (homeassistant минимальная версия)
- [ ] Указать домен: "smart_vent"

### 1.3 Создание const.py
- [ ] Определить DOMAIN = "smart_vent"
- [ ] Определить константы для режимов: LOW, MID, BOOST
- [ ] Определить константы для скоростей по умолчанию
- [ ] Определить интервал проверки по умолчанию
- [ ] Определить максимум boost по умолчанию

---

## Этап 2: Базовая инициализация компонента
**Цель**: Настроить загрузку компонента в Home Assistant

### 2.1 Создание схемы конфигурации
- [ ] Создать файл `config_flow.py` (пока заглушка)
- [ ] В `__init__.py` добавить импорты voluptuous
- [ ] Создать CONFIG_SCHEMA с полями:
  - fan_entity
  - humidity_sensor
  - input_0
  - input_1
  - speeds (optional)
  - check_interval (optional)
  - max_boosts_per_day (optional)

### 2.2 Функция async_setup
- [ ] Создать функцию `async_setup(hass, config)`
- [ ] Получить конфигурацию из config
- [ ] Сохранить конфигурацию в `hass.data[DOMAIN]`
- [ ] Вернуть True
- [ ] Добавить базовое логирование "Component loaded"

---

## Этап 3: Создание класса координатора
**Цель**: Создать координатор для управления состоянием

### 3.1 Создание файла coordinator.py
- [ ] Создать `coordinator.py`
- [ ] Импортировать `DataUpdateCoordinator`
- [ ] Создать класс `SmartVentCoordinator(DataUpdateCoordinator)`

### 3.2 Инициализация координатора
- [ ] Добавить `__init__` с параметрами:
  - hass
  - fan_entity
  - humidity_sensor
  - input_0
  - input_1
  - speeds
  - check_interval
  - max_boosts_per_day
- [ ] Сохранить все параметры как атрибуты
- [ ] Инициализировать счётчики и таймеры (пока None)

### 3.3 Базовая функция обновления
- [ ] Создать метод `async _async_update_data(self)`
- [ ] Пока просто возвращать пустой dict
- [ ] Добавить обработку исключений

---

## Этап 4: Чтение состояния переключателя
**Цель**: Научиться читать состояние трёхпозиционного переключателя

### 4.1 Метод чтения входов
- [ ] Создать метод `_get_switch_state(self)` в координаторе
- [ ] Получить состояние `self.input_0` через `hass.states.get()`
- [ ] Получить состояние `self.input_1` через `hass.states.get()`
- [ ] Вернуть кортеж (state0, state1)

### 4.2 Определение режима переключателя
- [ ] Создать метод `_determine_switch_mode(self)`
- [ ] Получить состояния через `_get_switch_state()`
- [ ] Реализовать логику:
  - off/off → "low"
  - on/off → "mid"
  - off/on → "boost"
  - on/on → "invalid"
- [ ] Вернуть режим как строку

### 4.3 Обработка недопустимого состояния
- [ ] При "invalid" логировать ошибку
- [ ] Возвращать "low" как безопасный режим
- [ ] Добавить тест логики в отладочном режиме

---

## Этап 5: Чтение датчика влажности
**Цель**: Получать текущее значение влажности

### 5.1 Метод чтения влажности
- [ ] Создать метод `_get_humidity(self)` в координаторе
- [ ] Получить состояние через `hass.states.get(self.humidity_sensor)`
- [ ] Проверить, что state существует
- [ ] Преобразовать state.state в float
- [ ] Обработать ошибки (None, unavailable, некорректное значение)
- [ ] Вернуть влажность или None при ошибке

### 5.2 Логирование значений
- [ ] Добавить debug логирование текущей влажности
- [ ] Логировать, если датчик недоступен

---

## Этап 6: Управление реальным вентилятором
**Цель**: Научиться устанавливать скорость вентилятора

### 6.1 Метод установки скорости
- [ ] Создать метод `async _set_fan_speed(self, percentage)` в координаторе
- [ ] Вызвать сервис `fan.set_percentage`:
  - entity_id = self.fan_entity
  - percentage = percentage
- [ ] Добавить обработку ошибок
- [ ] Логировать установленную скорость

### 6.2 Проверка доступности вентилятора
- [ ] Проверять, что fan_entity существует перед установкой
- [ ] Логировать ошибку, если сущность недоступна
- [ ] Не падать при ошибке, просто пропускать установку

---

## Этап 7: Базовая логика режимов (без автоматики)
**Цель**: Реализовать переключение режимов вручную

### 7.1 Хранение текущего режима
- [ ] Добавить `self.current_mode = "low"` в `__init__`
- [ ] Добавить `self.target_speed = self.speeds["low"]` в `__init__`

### 7.2 Метод установки режима
- [ ] Создать метод `async set_mode(self, mode)` в координаторе
- [ ] Проверить, что mode in ["low", "mid", "boost"]
- [ ] Установить `self.current_mode = mode`
- [ ] Получить скорость из `self.speeds[mode]`
- [ ] Вызвать `_set_fan_speed(speed)`
- [ ] Логировать смену режима

### 7.3 Интеграция в _async_update_data
- [ ] В `_async_update_data` вызывать `_determine_switch_mode()`
- [ ] Если режим переключателя изменился, вызывать `set_mode()`
- [ ] Возвращать dict с текущим режимом и скоростью

---

## Этап 8: Создание платформы Fan
**Цель**: Создать виртуальную сущность fan.smart_vent

### 8.1 Создание файла fan.py
- [ ] Создать файл `fan.py` в папке компонента
- [ ] Импортировать базовые классы от HomeAssistant
- [ ] Импортировать `FanEntity` из `homeassistant.components.fan`

### 8.2 Функция async_setup_entry
- [ ] Создать `async def async_setup_platform(hass, config, async_add_entities, discovery_info=None)`
- [ ] Получить координатор из `hass.data[DOMAIN]`
- [ ] Создать экземпляр `SmartVentFan(coordinator)`
- [ ] Добавить через `async_add_entities([fan])`

### 8.3 Класс SmartVentFan
- [ ] Создать класс `SmartVentFan(FanEntity)`
- [ ] Добавить `__init__(self, coordinator)`
- [ ] Сохранить coordinator как атрибут
- [ ] Добавить `@property name` → "Smart Ventilation"
- [ ] Добавить `@property unique_id` → "smart_vent_fan"

### 8.4 Базовые свойства
- [ ] `@property is_on` → всегда True (вентилятор не выключается)
- [ ] `@property percentage` → из coordinator.target_speed
- [ ] `@property speed_count` → 100 (поддержка процентов)

### 8.5 Регистрация платформы в __init__.py
- [ ] В `async_setup` загрузить платформу fan
- [ ] Передать координатор в discovery_info

---

## Этап 9: Сервисы управления
**Цель**: Добавить сервисы для управления из Home Assistant

### 9.1 Регистрация сервиса set_mode
- [ ] В `__init__.py` создать функцию `async def handle_set_mode(call)`
- [ ] Получить coordinator из `hass.data[DOMAIN]`
- [ ] Получить mode из `call.data.get("mode")`
- [ ] Вызвать `await coordinator.set_mode(mode)`
- [ ] Зарегистрировать сервис через `hass.services.async_register()`

### 9.2 Регистрация сервиса set_speed
- [ ] Создать функцию `async def handle_set_speed(call)`
- [ ] Получить percentage из `call.data.get("percentage")`
- [ ] Вызвать `await coordinator._set_fan_speed(percentage)`
- [ ] Зарегистрировать сервис

### 9.3 Создание файла services.yaml
- [ ] Создать `services.yaml` в папке компонента
- [ ] Описать сервис `set_mode` с параметром mode (selector)
- [ ] Описать сервис `set_speed` с параметром percentage (0-100)

---

## Этап 10: Автоматический boost - структура
**Цель**: Подготовить инфраструктуру для автоматического boost

### 10.1 Добавление атрибутов в координатор
- [ ] `self.auto_boost_active = False` — флаг активного авто-boost
- [ ] `self.auto_boost_end_time = None` — время окончания boost
- [ ] `self.auto_boost_count_today = 0` — счётчик boost за день
- [ ] `self.last_reset_date = None` — дата последнего сброса счётчика

### 10.2 Метод сброса счётчика
- [ ] Создать метод `_reset_daily_counter_if_needed(self)`
- [ ] Получить текущую дату через `datetime.now().date()`
- [ ] Если дата изменилась с `last_reset_date`:
  - Сбросить `auto_boost_count_today = 0`
  - Обновить `last_reset_date`
- [ ] Вызывать этот метод в начале `_async_update_data`

---

## Этап 11: Автоматический boost - активация
**Цель**: Реализовать включение автоматического boost

### 11.1 Метод проверки условий для boost
- [ ] Создать метод `_should_trigger_auto_boost(self)`
- [ ] Проверить: режим переключателя == "mid"
- [ ] Проверить: влажность > 80%
- [ ] Проверить: `auto_boost_active == False`
- [ ] Проверить: `auto_boost_count_today < max_boosts_per_day`
- [ ] Вернуть True/False

### 11.2 Метод активации boost
- [ ] Создать метод `async _activate_auto_boost(self)`
- [ ] Установить `auto_boost_active = True`
- [ ] Рассчитать `auto_boost_end_time = now + 20 минут`
- [ ] Увеличить `auto_boost_count_today += 1`
- [ ] Вызвать `_set_fan_speed(self.speeds["boost"])`
- [ ] Логировать активацию boost

### 11.3 Интеграция в основной цикл
- [ ] В `_async_update_data` после определения режима переключателя
- [ ] Если режим == "mid" и `_should_trigger_auto_boost()`:
  - Вызвать `_activate_auto_boost()`

---

## Этап 12: Автоматический boost - деактивация
**Цель**: Реализовать выключение автоматического boost

### 12.1 Метод проверки окончания boost
- [ ] Создать метод `_check_auto_boost_timeout(self)`
- [ ] Если `auto_boost_active == False`: return
- [ ] Получить текущее время
- [ ] Если `now >= auto_boost_end_time`:
  - Установить `auto_boost_active = False`
  - Установить `auto_boost_end_time = None`
  - Вернуть True (boost закончился)
- [ ] Иначе вернуть False

### 12.2 Возврат в режим mid
- [ ] В `_async_update_data` после проверки режима
- [ ] Вызвать `_check_auto_boost_timeout()`
- [ ] Если вернул True и режим переключателя == "mid":
  - Вызвать `set_mode("mid")` для возврата к обычной скорости
- [ ] Логировать окончание boost

### 12.3 Отмена boost при смене режима
- [ ] В методе `set_mode()` в начале
- [ ] Если `auto_boost_active == True`:
  - Установить `auto_boost_active = False`
  - Установить `auto_boost_end_time = None`
  - Логировать отмену авто-boost

---

## Этап 13: Приоритеты управления
**Цель**: Правильно обработать приоритеты ручного и автоматического управления

### 13.1 Обработка ручного boost
- [ ] В `_async_update_data` если режим переключателя == "boost":
  - Если `auto_boost_active == True`: отменить авто-boost
  - Установить режим "boost" (ручной)
  - Не запускать таймер

### 13.2 Обработка режима mid с активным авто-boost
- [ ] В `_async_update_data` если режим переключателя == "mid":
  - Если `auto_boost_active == True` и таймер не истёк:
    - Оставить скорость boost
    - Не менять режим на mid
  - Иначе:
    - Установить режим mid

### 13.3 Обработка режима low
- [ ] В `_async_update_data` если режим переключателя == "low":
  - Если `auto_boost_active == True`: отменить авто-boost
  - Установить режим "low"

---

## Этап 14: Сервис force_boost
**Цель**: Добавить возможность принудительного включения boost

### 14.1 Создание метода force_boost
- [ ] Создать метод `async force_boost(self, duration=20)` в координаторе
- [ ] Проверить лимит: `auto_boost_count_today < max_boosts_per_day`
- [ ] Если превышен: логировать ошибку и выйти
- [ ] Вызвать `_activate_auto_boost()` с custom duration
- [ ] Модифицировать `_activate_auto_boost()` для поддержки duration

### 14.2 Регистрация сервиса
- [ ] В `__init__.py` создать handler `handle_force_boost(call)`
- [ ] Получить duration из call.data (optional, default 20)
- [ ] Вызвать `await coordinator.force_boost(duration)`
- [ ] Зарегистрировать сервис

### 14.3 Описание в services.yaml
- [ ] Добавить описание сервиса `force_boost`
- [ ] Добавить параметр duration (optional, number, 1-120 минут)

---

## Этап 15: Binary sensor для авто-boost
**Цель**: Создать индикатор активности автоматического boost

### 15.1 Создание файла binary_sensor.py
- [ ] Создать `binary_sensor.py`
- [ ] Импортировать `BinarySensorEntity`
- [ ] Создать функцию `async_setup_platform()`

### 15.2 Класс AutoBoostSensor
- [ ] Создать класс `AutoBoostSensor(BinarySensorEntity)`
- [ ] Добавить `__init__(self, coordinator)`
- [ ] `@property name` → "Smart Vent Auto Boost"
- [ ] `@property unique_id` → "smart_vent_auto_boost"
- [ ] `@property is_on` → coordinator.auto_boost_active

### 15.3 Регистрация платформы
- [ ] В `async_setup` загрузить платформу binary_sensor
- [ ] Передать coordinator

---

## Этап 16: Restore state - подготовка
**Цель**: Настроить сохранение и восстановление состояния

### 16.1 Добавление RestoreEntity
- [ ] В `fan.py` импортировать `RestoreEntity`
- [ ] Изменить `SmartVentFan(FanEntity)` на `SmartVentFan(FanEntity, RestoreEntity)`

### 16.2 Метод async_added_to_hass
- [ ] Добавить метод `async_added_to_hass(self)` в SmartVentFan
- [ ] Вызвать `await super().async_added_to_hass()`
- [ ] Получить last_state через `await self.async_get_last_state()`
- [ ] Если state существует, передать в coordinator для восстановления

### 16.3 Метод сохранения в координаторе
- [ ] Создать метод `get_state_for_restore(self)` в координаторе
- [ ] Вернуть dict с:
  - current_mode
  - auto_boost_active
  - auto_boost_end_time (timestamp)
  - auto_boost_count_today
  - last_reset_date

---

## Этап 17: Restore state - восстановление
**Цель**: Реализовать восстановление состояния после перезагрузки

### 17.1 Метод восстановления в координаторе
- [ ] Создать метод `restore_from_state(self, state_dict)` в координаторе
- [ ] Восстановить `current_mode`
- [ ] Восстановить `auto_boost_active`
- [ ] Восстановить `auto_boost_end_time` из timestamp
- [ ] Восстановить `auto_boost_count_today`
- [ ] Восстановить `last_reset_date`

### 17.2 Проверка актуальности boost после восстановления
- [ ] После восстановления вызвать `_check_auto_boost_timeout()`
- [ ] Если boost истёк за время отсутствия HA:
  - Деактивировать boost
  - Установить режим согласно переключателю

### 17.3 Сохранение состояния
- [ ] В fan.py переопределить `@property extra_state_attributes`
- [ ] Вернуть `coordinator.get_state_for_restore()`
- [ ] HA автоматически сохранит эти атрибуты

---

## Этап 18: Логирование
**Цель**: Добавить полноценное логирование всех событий

### 18.1 Настройка logger
- [ ] В начале `__init__.py` создать logger:
  ```python
  _LOGGER = logging.getLogger(__name__)
  ```

### 18.2 Логирование в координаторе
- [ ] Смена режима: INFO уровень
- [ ] Активация boost: INFO уровень
- [ ] Деактивация boost: INFO уровень
- [ ] Превышение лимита boost: WARNING уровень
- [ ] Недопустимое состояние переключателя: ERROR уровень
- [ ] Недоступность датчиков: WARNING уровень

### 18.3 Логирование ошибок
- [ ] Обернуть все сетевые вызовы в try/except
- [ ] Логировать исключения на ERROR уровне
- [ ] Не падать при ошибках, продолжать работу

---

## Этап 19: Тестирование базовых сценариев
**Цель**: Проверить работу компонента в основных режимах

### 19.1 Тест установки
- [ ] Скопировать компонент в `custom_components/`
- [ ] Перезапустить Home Assistant
- [ ] Проверить отсутствие ошибок в логах
- [ ] Проверить, что компонент загрузился

### 19.2 Тест ручного управления
- [ ] Переключить физический переключатель в low
- [ ] Проверить, что скорость = 30%
- [ ] Переключить в mid → скорость = 52%
- [ ] Переключить в boost → скорость = 100%

### 19.3 Тест сервисов
- [ ] Вызвать `smart_vent.set_mode` с mode=low
- [ ] Проверить изменение скорости
- [ ] Вызвать `smart_vent.set_speed` с percentage=75
- [ ] Проверить прямое управление скоростью

---

## Этап 20: Тестирование автоматического boost
**Цель**: Проверить работу автоматики по влажности

### 20.1 Тест активации
- [ ] Установить переключатель в mid
- [ ] Имитировать влажность > 80% (через developer tools)
- [ ] Дождаться следующего цикла проверки (20 сек)
- [ ] Проверить, что скорость = 100% (boost)
- [ ] Проверить, что binary_sensor.smart_vent_auto_boost = on

### 20.2 Тест деактивации по таймеру
- [ ] Дождаться истечения 20 минут
- [ ] Проверить, что скорость вернулась к 52% (mid)
- [ ] Проверить, что binary_sensor = off

### 20.3 Тест отмены boost переключателем
- [ ] Активировать авто-boost
- [ ] Переключить переключатель в low
- [ ] Проверить немедленную отмену boost
- [ ] Проверить скорость = 30%

---

## Этап 21: Тестирование лимитов и ошибок
**Цель**: Проверить обработку граничных случаев

### 21.1 Тест превышения лимита boost
- [ ] Вызвать `force_boost` 5 раз за день
- [ ] Попытаться вызвать 6-й раз
- [ ] Проверить, что boost не активировался
- [ ] Проверить наличие WARNING в логах

### 21.2 Тест недопустимого состояния переключателя
- [ ] Имитировать input_0=on, input_1=on
- [ ] Проверить, что установился режим low
- [ ] Проверить наличие ERROR в логах

### 21.3 Тест недоступности датчиков
- [ ] Установить датчик влажности в unavailable
- [ ] Проверить, что компонент продолжает работать
- [ ] Проверить, что boost не срабатывает
- [ ] Проверить наличие WARNING в логах

---

## Этап 22: Тестирование restore state
**Цель**: Проверить восстановление после перезагрузки

### 22.1 Тест восстановления режима
- [ ] Установить режим mid через переключатель
- [ ] Перезапустить Home Assistant
- [ ] Проверить, что режим остался mid
- [ ] Проверить, что скорость = 52%

### 22.2 Тест восстановления активного boost
- [ ] Активировать авто-boost
- [ ] Перезапустить HA через 5 минут после начала boost
- [ ] Проверить, что boost продолжается
- [ ] Проверить, что таймер корректно отсчитывает оставшееся время
- [ ] Дождаться окончания boost (оставшиеся 15 минут)
- [ ] Проверить деактивацию

### 22.3 Тест восстановления истёкшего boost
- [ ] Активировать авто-boost
- [ ] Остановить HA
- [ ] Подождать 25 минут (больше 20)
- [ ] Запустить HA
- [ ] Проверить, что boost деактивирован
- [ ] Проверить, что режим соответствует переключателю

---

## Этап 23: Документация
**Цель**: Создать документацию для пользователей

### 23.1 README.md
- [ ] Описание компонента
- [ ] Требования (Home Assistant версия, устройства)
- [ ] Инструкция по установке через HACS
- [ ] Пример конфигурации в configuration.yaml
- [ ] Описание режимов работы
- [ ] Описание сервисов

### 23.2 Примеры автоматизаций
- [ ] Пример автоматизации с force_boost по кнопке
- [ ] Пример автоматизации по расписанию
- [ ] Пример использования в Lovelace UI

### 23.3 Troubleshooting
- [ ] Как проверить логи
- [ ] Частые проблемы и решения
- [ ] Как проверить состояние датчиков

---

## Этап 24: Подготовка к публикации в HACS
**Цель**: Подготовить компонент к публикации

### 24.1 Структура репозитория
- [ ] Создать репозиторий на GitHub
- [ ] Добавить папку `custom_components/smart_vent/`
- [ ] Добавить README.md
- [ ] Добавить LICENSE (MIT или Apache 2.0)
- [ ] Добавить .gitignore

### 24.2 Файлы HACS
- [ ] Создать `hacs.json`:
  - name
  - content_in_root: false
  - filename: smart_vent
  - render_readme: true
- [ ] Убедиться, что manifest.json корректен
- [ ] Добавить версионирование через tags

### 24.3 GitHub Actions (опционально)
- [ ] Настроить автоматическую проверку кода
- [ ] Настроить автоматический release при tag push

---

## Этап 25: Оптимизация и полировка
**Цель**: Улучшить производительность и UX

### 25.1 Оптимизация опроса
- [ ] Убедиться, что опрос датчиков не слишком частый
- [ ] Рассмотреть использование event listeners вместо polling где возможно
- [ ] Добавить throttling для изменений скорости

### 25.2 Улучшение UX
- [ ] Добавить атрибуты в fan entity:
  - Время до окончания boost
  - Количество использованных boost сегодня
  - Текущая влажность
- [ ] Рассмотреть добавление sensor для оставшегося времени boost

### 25.3 Расширяемость
- [ ] Сделать легко добавляемыми новые условия (CO₂, время суток)
- [ ] Документировать точки расширения в коде
- [ ] Создать примеры кастомизации

---

## Этап 26: Финальное тестирование
**Цель**: Провести полное end-to-end тестирование

### 26.1 Полный цикл использования
- [ ] Установить компонент с нуля
- [ ] Настроить конфигурацию
- [ ] Проверить все режимы
- [ ] Проверить все сервисы
- [ ] Проверить автоматический boost
- [ ] Проверить restore state
- [ ] Проверить логи

### 26.2 Длительное тестирование
- [ ] Оставить компонент работающим на несколько дней
- [ ] Проверить стабильность
- [ ] Проверить корректность сброса дневного счётчика
- [ ] Проверить отсутствие утечек памяти

### 26.3 Edge cases
- [ ] Быстрое переключение режимов
- [ ] Одновременное изменение влажности и режима
- [ ] Множественные перезагрузки HA
- [ ] Изменение конфигурации без перезагрузки

---

## Итоговый чеклист готовности к релизу

- [ ] Все этапы 1-26 выполнены
- [ ] Код соответствует стандартам Python (PEP 8)
- [ ] Нет критических ошибок в логах
- [ ] Документация полная и понятная
- [ ] Компонент работает стабильно минимум 7 дней
- [ ] Все edge cases обработаны
- [ ] Репозиторий GitHub готов к публикации
- [ ] manifest.json, hacs.json, README.md заполнены
- [ ] Версия 1.0.0 готова к релизу

---

## Рекомендуемая последовательность выполнения

**Фаза 1 - Базовая функциональность (Этапы 1-9)**
Минимально работающий компонент с ручным управлением

**Фаза 2 - Автоматика (Этапы 10-15)**
Добавление автоматического boost по влажности

**Фаза 3 - Надёжность (Этапы 16-18)**
Restore state и логирование

**Фаза 4 - Тестирование (Этапы 19-22)**
Полное тестирование всех сценариев

**Фаза 5 - Публикация (Этапы 23-26)**
Документация, HACS, финальная полировка

---

*Каждый этап можно выполнять независимо, но рекомендуется следовать указанной последовательности для минимизации переделок.*